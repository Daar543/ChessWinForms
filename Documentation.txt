This project has been made to allow players play chess against AI, and against each other, or AI against AI.
The project consists mostly of two parts: the Form, which is necessary for Winforms apps, and the class "Engine" - which was originally made for console chess application.

I. Engine


1) Purpose

The "Engine" takes care of these things:

- creating state of new game
- tracking pieces' positions and other aspects of the board (e.g. which side is to move)
- recording notation of current game
- game rules (all possible moves, end of game...)
- "thinking" of AI 

2) Important variables

The engine is able to track only one state of the board. This is being done by the following variables:

2A) Board state

a) ulong[] BitBoards

A bitboard is a term used in chess programming to represent one flag for all squares on a chess board with use of one integer. 
Since ulong variable has 64 bits as well as chess board has squares, each square can be represented by one bit. 
If a bit on a given position is set, the flag is active. This can be easily checked by bit operations (see method Bit()).

The array BitBoards consists of 12 such bitboards,
with each index representing one piece:

0-5: white
0 - king
1 - pawn
2 - knight
3 - bishop
4 - rook
5 - queen
6-11: black
6 - king
7 - pawn
8 - knight
9 - bishop
10 - rook
11 - queen

This allows to easily check if a piece is present on given square: 
if we want to check if a white rook is present of square b7 (which has index of 9), then we check if 9th LSb in BitBoards[4] is set.

b) ulong Wmask, ulong Bmask, ulong Block

Wmask is a disjunction of white pieces' bitboards, Bmask a disjunction of black pieces' bitboards and Block is a disjunction of Wmask and Bmask.

These variables can quickly speed up searching. For example, if we want to know if any piece is present on square #6,
then instead of looping through all pieces' bitboards, we can first check the 6th bit in Block, then Wmask or Bmask. In worst case, we will need to do 9 bit checks (black queen), but if a piece is not present, we will need to do only 1 bit check.

All of these variables must be updated as soon as the BitBoards[] themselves are updated.

c) int Position

While knowing location of all pieces on the board gives us lots of information (and in some cases, complete information), the position mostly requires some pieces of external information.
Below are shown the aspects of position which are kept in this variable, with corresponding bits (LSb first):

Castling rights (c8, g8, c1, g1): 0-3
Player currently to move (1 white, 0 black): 4
Square behind pawn which had just made a double-step (en passant square): 8-13
Total half-moves (not implemented yet): 14-23
Half-moves without piece being captured or pawn moving: 24-31

d) ulong CurrentHash

This variable is used for detecting repeated positions: one purpose is to detect threefold repetition 
(not implemented due to analysis issues), the other is to implement Transposition Table in order to improve speed of depth analysis.

Every position could be uniquely encoded in this way: concatenate BitBoards and Position, leading to 800-bit integer. 
This encoding would hold little value to hash tables due to its size. The idea of hashing in this project (called Zobrist Hashing) is to 
generate a random ulong value for every bit, and then xor values where the bit is equal to 1.

e) ulong[] HashSeed, const int randomSeed

HashSeed is an array of 784 ulongs, used for Zobrist Hashing (see CurrentHash). 
12*64 numbers are used for representing every piece-square combinations, 1 number for beginning player, 4 numbers for castling rights,
and 8 numbers for file where en-passant can take place in the next move.

Although the numbers in array are generated randomly, the seed is constant - in order to have constant hashing at every launch.

f) int Wking, int Bking

As there can be only one king, it's simple to track his location by one integer rather than ulong. This comes in handy when
there is need to check for checking/mate, as there is no need to loop through king's bitboard.

g) bool white

Many function are based on the fact whether a white or black player is currently making move, so this variable is used very often.

2B) Movement of pieces, board representation

Indices in normal board representation starts at square a8 and procceeds left-to-right, therefore directions are as following:
west: -1
east: +1
north: -8
south: +8

Indices of squares:
a8: 0
b8: 1
h8: 7
a1: 56
h1: 63

a) int[] Indices, int[] Deinds

Array Indices is made for converting "normal" indices to so-called 0x88 representation.
In this representation, south/north movement changes index by +/- 16. This results in two things:

- maximum value, h1 square, is equal to 119.
- if (index & 0x88) is not zero, a square with this index doesn't exist on board.

The advantage of this representation is that it's easier to check whether a piece has moved outside the board,
 as it requires one bit operation and equality statement rather than 4 comparisons.

Deinds returns 0x88 representation into normal one. Invalid squares have value of -1.
This cannot be used to detect all invalid squares, as some of them can have negative value or higher value than 119.

b) int[] Directions_King (Knight, Rook, Bishop, Queen, Pawn_White, Pawn_Black)

These integers represent a change of square's index (in 0x88 representation, see 2B/a Indices) if a piece moves by 1 point in the given directions. 
King, knight and queen can move in 8 directions, while rook and bishop can move in 4 directions. Pawns have specific movement.

c) ulong[] AllKingMoves, ulong[] AllKnightMoves

Both of these represent bitboard of all possible moves which can be made by king or knight on empty board, 
based only on the initial square. 
If I need to know possible pseudolegal moves for current position, 
I need only to exclude squares where pieces of the same color (as the moving piece) are.

2C) Evaluation

Unless the AI or player can see a forced mate or draw, 
it needs to have a way to determine if a position at the end of calculation is advantageous. Following variables employ this purpose:

a) int[] Values

Classic "chess school" values of pieces are as following:

King - practical infinity 
Pawn - 1
Knight - 3
Bishop - 3 
Rook - 5
Queen - 9

In order to reach more precision by next evaluation factors, I have multiplied the values by 100 (to avoid floats)
 and also increased the value of bishop and knight to discourage disadvantageous exchanges (e.g. knight+bishop > rook+pawn):

King - 65535
Pawn - 100
Knight - 320
Bishop - 330
Rook - 500
Queen - 900

As both sides have king, its material value is not considered in the evaluation functions.

b) int[][]Posit_Values

To every piece is assigned additional value, based on the currently occupied square. 
The values are based on mobility on empty board, and also how the pieces are often threatened/blocked in games. 
For example, knights are encouraged to be developed almost immediately, whereas pawns are advised to stay in back. 
Therefore the computer tries to move first knights, and move with pawns only to enable other pieces.

King has two separate values, one for early and middle game, the other one for late game (based on current material).

c) uint[] Priorities

If a capture is available, the computer first analyzes the capture made by piece with highest priority (which is the weaker one).
This is based on normal principle of piece trading - usually capturing pieces can be recaptured, 
therefore captures by pawn are usually the strongest captures of them all  
(Searching best moves first increases efficiency of search algorithm).

d) int depth_base, int deph

These variables tell AI how deep should it search, before ending with unlimited "quiescence" search. 
Variable depth_base is assigned to the engine at start of game, while deph is the actual depth -
- it increases once material in position drops under certain value.

In case of lower material, there are usually less moves to be made, therefore the search is faster, and therefore computer can spend 
its assigned time by searching deeper.

Additionally, endgames require very precise calculation, and player can often see further than the computer, if moves are forced.

e) const int blacksquares, whitesquares

This is a constant for bitboard of blacksquares (black squares have a set bit) or whitesquares. 
Used when determining if bishops are on the same color (as they move only diagonally, so the color stays).

3) Functions

First of all, I would like to apologize for inconsistencies in "early" functions, where I used variables Wmask, Bmask... as parameters.
The functions could use some cleaning, but they work.

3A) Helper functions

a)  bool Bit(ulong bitboard, int Pos),
bool Bit(int number, int Pos)
Checks if a bit is set on Pos position of the integer.

b) void XH(int where)

Changes the Zobrist hash (see HashSeed) by xoring it by number on "where" index.

c) ulong[] GenRandomNumbers(int howmany, int seed)

Generates an array of ulongs (Length = howmany).

d) class ULongRandom

A class for easy generation of long random numbers 

e) int HammingWeight(ulong x)

Returns amount of set bits in the ulong x.

3B) Generating moves

The general algoritm is: 
- Initialize bitboard of target squares
- Loop through all directions of a piece
	- Loop through all distances in this direction
		- If outside board, break
		- Else add the target square into bitboard
		- If there is a piece on this square, break for this directionÂ¨
- Negate the bitboard by bitboards of pieces of the same color

a) ulong Land_Moves(int[] Directions, int index, ulong WhiteBoard, ulong BlackBoard, ulong Block, bool white)

This generates a bitboard of possible moves for "landing" pieces, which are king and knight.
If one of the target squares for this piece is blocked, it has no impact on other squares where this piece can move. 

b) ulong Ray_Moves(int[] Directions, int index, ulong WhiteBoard, ulong BlackBoard, ulong Block, bool white)

This generates a bitboard of possible moves for "ray" pieces, which can move by more squares in one direction (bishop, rook, queen).
If moves are generated in one direction, then if a square is blocked, all other squares past it will be unavailable 
(as pieces cannot jump).

c) ulong Land_Captures(int[] Directions, int index, ulong WhiteBoard, ulong BlackBoard, ulong Block, bool white)
ulong Land_Captures_Premade(ulong[] table, int index, ulong WhiteBoard, ulong BlackBoard, ulong Block, bool white)

This function generates only captures, and could be used e.g. when determining if king is in check.
Generation is the same as for all moves, the only difference is that squares where no piece of the opposite color resides are excluded.

However, if I exclude the two last and-operations, the bitboard will be based only on the initial square. 
That's what the function Land_Captures_Premade is made for. The ulong[]table is either of the AllKingMoves or AllKnightMoves (see 2B/c)
	
d) ulong Ray_Captures(int[] Directions, int index, ulong WhiteBoard, ulong BlackBoard, ulong Block, bool white)

This function generates only captures for bishop, rook or queen. 
Difference between this function and function Ray_Moves is that if square is not blocked, 
it is not added to the bitboard of possible captures (as there is no piece to be taken).

At the end of function, final filtering is being made - 
squares with the pieces of same color are excluded, squares with pieces of opposite color are included.

e) ulong FreeKingMoves(int index), ulong FreeKnightMoves(int index)

These generate bitboard for all possible moves of king/knight on empty board, at the given #index square.

f) ulong[] initKingMoves(), ulong[] initKnightMoves()

Efficient generation of arrays AllKingMoves and AllKnightMoves, respectively.

g) ulong Bishop_Moves(int index, ulong WhiteBoard, ulong BlackBoard, ulong Block, bool white),
ulong Rook_Moves(int index, ulong WhiteBoard, ulong BlackBoard, ulong Block, bool white),
ulong Queen_Moves(int index, ulong WhiteBoard, ulong BlackBoard, ulong Block, bool white)

All of these functions call function Ray_Moves with specific direction for each piece, 
producing a bitboard of pseudolegal moves for these pieces.

h) ulong King_Moves(int index, ulong WhiteBoard, ulong BlackBoard, ulong Block, bool white),
ulong Knight_Moves(int index, ulong WhiteBoard, ulong BlackBoard, ulong Block, bool white)

These functions call Land_Moves with direction for king or knight, respectively, 
producing a bitboard of pseudolegal moves for these pieces.
This function is not used in the generation itself (see MovesKing, MovesKnight)

i) ulong MovesBishop(int index, ulong WhiteMask, ulong BlackMask, ulong Block, bool white),
ulong MovesRook(int index, ulong WhiteMask, ulong BlackMask, ulong Block, bool white),
ulong MovesQueen(int index, ulong WhiteMask, ulong BlackMask, ulong Block, bool white)

A rewriting of functions Bishop_Moves, Rook_Moves, Queen_Moves for the sake of consistency (see MovesKing, MovesKnight).

j) ulong MovesKing(int index, ulong WhiteMask, ulong BlackMask, ulong Block, bool white),
ulong MovesKnight(int index, ulong WhiteMask, ulong BlackMask, ulong Block, bool white)

Unlike MovesBishop,MovesRook or MovesQueen, these functions use static arrays AllKingMoves or AllKnightMoves for move generation.

k) ulong CapturesKing(int index, ulong WhiteMask, ulong BlackMask, ulong Block, bool white),
ulong CapturesKnight(int index, ulong WhiteMask, ulong BlackMask, ulong Block, bool white),
ulong CapturesBishop(int index, ulong WhiteMask, ulong BlackMask, ulong Block, bool white),
ulong CapturesRook(int index, ulong WhiteMask, ulong BlackMask, ulong Block, bool white),
ulong CapturesQueen(int index, ulong WhiteMask, ulong BlackMask, ulong Block, bool white)

Returns bitboard of pseudolegal captures of corresponding piece.

l) ulong MovesPawn(int index, ulong WhiteMask, ulong BlackMask, ulong Block, bool white)

Generates a bitboard for pawn's moves, excluding en-passant. Given pawns' irregular movement, every case is resolved specifically.

m) ulong genCapturesPawn(int index, bool white)

Returns bitboard of squares which are currently attacked by white/black pawn.

n) short genECapturesPawn(int index, bool white)

Returns two-byte number. Each byte is an index of square which is attacked by pawn on input index. 
This means if only one capture is available, the other square will be wrongly presented as a8 (index 0), 
but this has no negative impact on purpose of this function.

o) ulong[] initPawnCaps(bool white),
short[] initEPawnCaps(bool white)

Efficient initialization of arrays CapturesPawn_White, CapturesPawn_Black, EP_Pawn_White, EP_Pawn_Black,
which are used as lookup tables.

p) byte Castling_White(int position), byte Castling_Black(int position)

Returns 0b00, 0b01, 0b10, 0b11 based on if white or black can castle kingside (upper bit) or queenside (lower bit) in current position.
The possibility of castling is based on:
- castling rights (if player hasn't moved king or rook yet, the right is valid)
- free squares between king and rook
- king not in check on all three squares

q) bool Attacked(int index, ulong WhiteMask, ulong BlackMask, ulong Block, bool white, ulong[] Bitboards)

Returns true if the square is attacked by at least one piece of the given color. Necessary for determining if king is checked.
As moves are generated from the square in question, the pawn's color is inverted.

r) ulong GenMoves(int index, int type, bool white, ulong WhiteMask, ulong BlackMask, ulong Block),
ulong GenCaptures(int index, int type, bool white, ulong WhiteMask, ulong BlackMask, ulong Block)

Wrappers for all move-generating functions. Excludes special moves, such as castling and en-passant captures.

s) int[] EPGen(int epsquare, bool white)

Generates two moves as integers (see function BuildMoveWhite, BuildMoveBlack), which represent en-passant captures.
For example, if the "epsquare" is 19 (=f6), then the incoded moves will be e5xf6 e.p., and g5xf6 e.p. 
under the condition a pawn is present on e5 or g5, respectively. 
If the en-passant capture cannot be generated, integer 0 will be returned in the array.

t) List<uint> MoveGeneration_White(ulong[] BBs),
List<uint> MoveGeneration_Black(ulong[] BBs),
List<uint> CapsGeneration_White(ulong[] BBs),
List<uint> CapsGeneration_Black(ulong[] BBs)

These functions generate list of all possible pseudolegal moves (or only captures) a given side can make. 
In the rest of this description, I will refer only to MoveGeneration_White.
For the format of move, see BuildMoveWhite.

First of all, the function has to find pieces capable of moving. This is done by scanning Wmask bitboard. 
When the bit on given index is set, the function scans through pieces' bitboards to find which exact piece resides on the square.
Once found, a bitboard for all moves of this piece is generated.
Lastly, this bitboard is scanned, and if a bit is set, it is possible to build a move using triplet "piece, square from, square to".

For special moves:
- if a pawn is promoted, move is copied 4 times, adding different promoted piece
- en-passant moves are generated separately
- castling is generated separately

3C) Evaluation of a position

a) int EndMateEval(bool white, int dep)

This function is called when a player has no legal move available. If a moving player is not checked, 
then the position is called stalemate and therefore has an evaluation of 0.

If a black player is to move and is checked, the position is evaluated as maximally positive for white. 
In order to encourage quicker mates (in less moves), the value is divied by the current depth - 
if the mate was found at higher depth, it means more moves were needed to reach that, and therefore is less advantageous.

Based on how Alphabeta function (see 3C/ ) works, the same evaluation is used when white is to move. 
Therefore, the result of this function is always non-negative.
If the argument "depth" was too high, the function could produce worse result than standard material evaluation. 
However, such depth is unrealistic for chess engines.


b) bool NoProgress()

From FIDE rules:
If 50 consecutive moves have been made without capturing a piece or moving a pawn, a player has right to claim a draw.
If 75 such moves have been made, position is instantly drawn.

I am calling these moves "blank moves" and declare a draw after 50 of these moves are made (with analysis evaluation of 0).


c) bool InsufMaterial()

A position is instantly drawn when there is no legal sequence of moves which can result in a mate.
Chess engines can detect only minority of these positions - as name suggests, when there are so little pieces that 
a mate position cannot be "built" from them.

Conditions needed to be met are these:
- no pawns, rooks or queens (pawns can promote to rook or queen, rooks and queens can mate with only help from king)
- bishops on only the same colored squares OR no bishops and only one knight (regardless of color)

In evaluation functions, these positions always return 0.

d) int LazyEvaluation(bool white)

Returns current amount of material of white/black player,excluding king. See 2C/a Values.

e) int Evaluation()

Evaluates the whole position by these factors:

- material (2C/a)
- bonus for position of each piece on the board (2C/b); rank is flipped for black pieces
- +0.4 pawns for bishop double (common strategical advantage; explanation - two bishops can never interfere with each other)
- different values for king in case of endgame (total material is less than 20 pawns total)

3D) Game progress

a) uint BuildMoveWhite(int piece, int from, int to)
uint BuildMoveBlack(int piece, int from, int to)

Returns 4-bit integer with these informations (MSB first):
first byte: upper 4 bits - which piece has been captured (0 if none), lower 4 bits - which piece has moved
second byte: square which has this piece moved from
third byte: square which has this piece moved to
fourth byte: capture flag (1b), kingside/queenside castling flag (2b), promotion flag (1b), promoted piece (2b),
	pawn-doublemove flag (1b), en-passant flag (1b)

Special moves, such as promotion (default to queen) and castling are resolved in this function as well.
If a pawn moves diagonally, en-passant flag is raised. If there is no piece (to capture)
	on the final square, then en-passant flag will stay raised.

b) uint[] MakeMove(uint move, bool white)

Returns array of two uints: first one is the input move, second one is current position state.
More importantly, changes the board state based on current move:

- changes bits on bitboards of affected pieces (moving,captured,promoted)
- changes position's hash
- flips player which is currently to move
- increments or nullifies blank move count
- changes castling rights or en-passant possiblity 
	(if a pawn makes a doublemove, square behind it is immediately flagged for en-passsant)

Some things, such as blank moves (no progress) or "positional" part of the hash 
are extracted from the corresponding variables, and returned to them at the end of function.

c) uint UndoMove(uint[] memo, bool white)

An inverse function to MakeMove (3D/c).
First element of the memo array is the previously made move - contains enough information to reconstruct the board state.
Second element of the memo array is Position state - other aspects, e.g. castling rights, are hidden in it. 
	Replacing the current Position variable with the input one is sufficient enough to reset these.

3E) Computer's analysis

a) int ComputersMove(bool white, int totmoves,int depth_base)

Warning: This function is not fully optimized, but is called only once per ply in each game, 
therefore does not have that high performance impact.

This function represents the full logic "computer" (AI) does when it is supposed to move.

One of the parameters is depth_base. That one is set by player, and represents minimal depth of 
how "deep" the computer is able to see.
Near the start of the function, computers checks current material. If it is too low, it improves its in-depth search
(endgames require more precision, but are also quicker to calculate).

After that, informative variables NodesSearched and TimeSpent are initialized (not used in form application).

Next, an array principalVariation is initialized and function AlphaBeta is called (see 3E/c).
This results in principalVariation be filled with series of best moves (according to AI), and 
variable analysisEvaluation will contain the evaluation of position
made after series of principalVariation moves.

After this, first move of principalVariation is chosen and made (see MakeMove, 3D/b).
A case that should not happen is that if move is illegal (which means there is no possible move). This would result in game's end.

Correct making of move results in notation of current game being updated, and saved in file "partie.txt" (rewrites old one).
If this move has created draw situation, game ends.

Returns either move that has been made (see BuildMoveWhite, 3D/a), or mate/stalemate/draw state:
 1 for draw, 2 for black wins, 3 for white wins.

b) int Quisce(int alpha, int beta, bool white, bool evaluation_system)




